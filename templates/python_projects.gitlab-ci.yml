include:
  - local: templates/base.gitlab-ci.yml


variables:
  # required to set:
  PACKAGES_TO_CHECK: ""
  # may be set:
  PYPROJECT_CONFIG_PATH: ""
  # uses registry.gitlab.syncad.com/hive/hive/ci-base-image:ubuntu22.04-8
  PYTHON_IMAGE_TAG: "@sha256:e9f16040010ad24fffeabec66abca109b24baa79d912eba3118da58e8130fb26"
  PYTHON_IMAGE: "registry.gitlab.syncad.com/hive/hive/ci-base-image${PYTHON_IMAGE_TAG}"
  # colors:
  TXT_GREEN: "\e[1;32m"
  TXT_BLUE: "\e[1;34m"
  TXT_CLEAR: "\e[0m"


.configuration_template:
  extends: .job-defaults
  image: "${PYTHON_IMAGE}"
  variables:
    PYPROJECT_DIR: "$(pwd)"

  before_script:
    - poetry -C "${PYPROJECT_DIR}" env use python3  # create virtualenv if not exists
    - source $(poetry -C "${PYPROJECT_DIR}" env info --path)/bin/activate  # activate that virtualenv
    - python3 -V
    - poetry -C "${PYPROJECT_DIR}" -V
    - pip list


.project_develop_configuration_template:
  extends: .configuration_template
  before_script:
    - !reference [.configuration_template, before_script]
    - poetry install
    - pip list


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>| STATIC CODE ANALYSIS |>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

.pre_commit_checks_template:
  extends: .project_develop_configuration_template
  script:
    - pushd . && cd /tmp && poetry self update && popd  # Bump poetry version so `poetry lock --no-update` will use the latest one; doing it in different directory to avoid `poetry.lock` and `pyproject.toml` changes
    - poetry -V
    - echo -e "${TXT_BLUE}Checking all files with pre-commit hooks...${TXT_CLEAR}" &&
      pre-commit run --all-files
  artifacts:
    when: always
    expire_in: 1 week
    paths:
      - poetry.lock

.lint_code_with_ruff_template:
  extends: .project_develop_configuration_template
  script:
    - if [ -z "${PYPROJECT_CONFIG_PATH}" ]; then MAYBE_EXPLICIT_CONFIG=""; else MAYBE_EXPLICIT_CONFIG="--config ${PYPROJECT_CONFIG_PATH}"; fi
    - echo -e "${TXT_BLUE}Linting all sources with Ruff (check)...${TXT_CLEAR}" &&
      ruff ${MAYBE_EXPLICIT_CONFIG} ${PACKAGES_TO_CHECK}
    - echo -e "${TXT_BLUE}Linting all sources with Ruff (diff)...${TXT_CLEAR}" &&
      ruff --diff ${MAYBE_EXPLICIT_CONFIG} ${PACKAGES_TO_CHECK}

.formatting_with_black_check_template:
  extends: .project_develop_configuration_template
  script:
    - if [ -z "${PYPROJECT_CONFIG_PATH}" ]; then MAYBE_EXPLICIT_CONFIG=""; else MAYBE_EXPLICIT_CONFIG="--config ${PYPROJECT_CONFIG_PATH}"; fi
    - echo -e "${TXT_BLUE}Checking code formatting with Black...${TXT_CLEAR}" &&
      black --check --diff --color ${MAYBE_EXPLICIT_CONFIG} ${PACKAGES_TO_CHECK}

.type_check_with_mypy_template:
  extends: .project_develop_configuration_template
  script:
    - if [ -z "${PYPROJECT_CONFIG_PATH}" ]; then MAYBE_EXPLICIT_CONFIG=""; else MAYBE_EXPLICIT_CONFIG="--config-file ${PYPROJECT_CONFIG_PATH}"; fi
    - echo -e "${TXT_BLUE}Checking types with mypy...${TXT_CLEAR}" &&
      mypy ${MAYBE_EXPLICIT_CONFIG} ${PACKAGES_TO_CHECK}

# job template useful to match project local poetry.lock file to pyproject.toml specification
# and avoid differences, which can potentially cause bugs really not reproducible on clean evironment.
.verify_poetry_lock_sanity_template:
  extends: .job-defaults
  variables:
    PYPROJECT_DIR: "" #should be overrided by inheritted job

  image: "${PYTHON_IMAGE}"
  script:
    - cd "${PYPROJECT_DIR}"
    - poetry lock --check # we have to stick to old syntax, because poetry-grpc-plugin used at wax repo disallows to upgrade poetry tool to version higher than 1.5.1

# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<| STATIC CODE ANALYSIS |<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>| BUILD |>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

.build_wheel_template:
  extends: .configuration_template
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0  # We need full history to get correct version (dynamic versioning)
  script:
    - echo -e "${TXT_BLUE}Building python wheel...${TXT_CLEAR}"
    - ls -al
    - poetry -C "${PYPROJECT_DIR}" version
    - poetry -C "${PYPROJECT_DIR}" build --format wheel
    - ls -al dist/
  after_script:
    - WHEEL_BUILD_VERSION=$(poetry -C "${PYPROJECT_DIR}" version -s)
    - echo "WHEEL_BUILD_VERSION is ${WHEEL_BUILD_VERSION}"
    - echo "WHEEL_BUILD_VERSION=${WHEEL_BUILD_VERSION}" > build_wheel.env
  artifacts:
    expire_in: 1 week
    paths:
      - dist/
      - build_wheel.env
    reports:
      dotenv: build_wheel.env

# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<| BUILD |<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>| DEPLOY |>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

.deploy_wheel_base:
  extends: .configuration_template
  when: manual
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0  # Required for poetry publish to get correct version
  before_script:
    - !reference [.configuration_template, before_script]
    - rm build_wheel.env  # to keep the git status clean
  after_script:
    # Job extending this template will depend on the build_wheel job, so we can use the same variable and pass it further
    # so jobs depending on deploy_wheel won't have to include build_wheel also just to get the version
    - echo "WHEEL_BUILD_VERSION is ${WHEEL_BUILD_VERSION}"
    - echo "WHEEL_BUILD_VERSION=${WHEEL_BUILD_VERSION}" > deploy_wheel.env
  artifacts:
    expire_in: 1 week
    paths:
      - deploy_wheel.env
    reports:
      dotenv: deploy_wheel.env

.deploy_wheel_to_gitlab_template:
  extends: .deploy_wheel_base
  script:
    - echo -e "${TXT_BLUE}Deploying python wheel to the GitLab PyPI registry...${TXT_CLEAR}"
    - ls -al
    - poetry -C "${PYPROJECT_DIR}" version
    - poetry -C "${PYPROJECT_DIR}" config repositories.gitlab "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/pypi"
    - poetry -C "${PYPROJECT_DIR}" config http-basic.gitlab gitlab-ci-token "${CI_JOB_TOKEN}"
    - poetry -C "${PYPROJECT_DIR}" publish --skip-existing --repository gitlab

.deploy_wheel_to_pypi_template:
  extends: .deploy_wheel_base
  rules:
    - if: '$CI_COMMIT_TAG && $CI_COMMIT_REF_PROTECTED == "true"'
      when: manual
      allow_failure: true
  variables:
    PYPI_AUTHORIZATION_TOKEN: $PYPI_AUTHORIZATION_TOKEN
  script:
    - echo -e "${TXT_BLUE}Deploying python wheel to the official PyPI registry...${TXT_CLEAR}"
    - ls -al
    - poetry -C "${PYPROJECT_DIR}" version
    - poetry -C "${PYPROJECT_DIR}" config pypi-token.pypi "${PYPI_AUTHORIZATION_TOKEN}"
    - poetry -C "${PYPROJECT_DIR}" publish --skip-existing

# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<| DEPLOY |<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
